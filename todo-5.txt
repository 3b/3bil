~~~closures

~~~nlx
 ----------
  need to return to correct exit-point from go/return-from
  bind a var to a unique value at entry to block/tagbody, then close over
  that in the return-from/go nlx, and use it to identify the correct
  activation
  ==
    (labels ((a (f c)
               (format t "enter ~s~%" c)
               (if (>= c 10)
                   (funcall f)
                   (if f
                       (a f (1+ c))
                       (a (lambda () (return-from a)) (1+ c))))
               (format t "exit ~s~%" c)))
      (a nil 0))

 ----------
~~~uwp

~~~tagbody

interning, defpackage?
  interning literal objects?
    ex: (eq #1=(cons 1 . 2) #1#)
    3.2.4.2.2 : http://www.lispworks.com/documentation/HyperSpec/Body/03_bdbb.htm

setf
  ~~~flet/labels
  global setf functions

global macros/global environment

lambda list keywords (&arest and &optional at least)

~~~jumps out of function call arglists

code cleanup

implement CL: stuff

inlining/compiler macros/etc
  inline cl stuff

real test framework, regression tests

arg count checking?

skip :coerce_foo when value is known to be correct type

store&use type info, allow type declarations
  (maybe some simple type propagation too?)

enforce same type on all exits from a block, or branches in an if
  (lazy way = specify coerce_a when no type specified externally,
   soem minimal type checking would be nicer though)

verifier in asm
  (possibly add fixer for some simple type errors too?)

top level closures?
    (let ((a 1))
      (defun a+1 () (incf a)))

get rid of unused bindings (exit-point in particular)

spill u-w-p return value to a local across cleanup if needed?
   (or maybe just always for now?)
 (unwind-protect 1 (catch 2 (throw 2))) -> 1?

---

http://www.lispworks.com/documentation/HyperSpec/Issues/iss152_w.htm
http://www.lispworks.com/documentation/HyperSpec/Body/03_af.htm
http://www.lispworks.com/documentation/HyperSpec/Body/05_b.htm
