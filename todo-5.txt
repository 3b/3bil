~~~closures

~~~nlx
 ----------
  need to return to correct exit-point from go/return-from
  bind a var to a unique value at entry to block/tagbody, then close over
  that in the return-from/go nlx, and use it to identify the correct
  activation
  ==
    (labels ((a (f c)
               (format t "enter ~s~%" c)
               (if (>= c 10)
                   (funcall f)
                   (if f
                       (a f (1+ c))
                       (a (lambda () (return-from a)) (1+ c))))
               (format t "exit ~s~%" c)))
      (a nil 0))

 ----------
~~~uwp

~~~tagbody

interning, defpackage?
  interning literal objects?
    ex: (eq #1=(cons 1 . 2) #1#)
    3.2.4.2.2 : http://www.lispworks.com/documentation/HyperSpec/Body/03_bdbb.htm

setf
  ~~~flet/labels
  global setf functions

global macros/global environment

lambda list keywords (&arest and &optional at least)

~~~jumps out of function call arglists

code cleanup

implement CL: stuff

inlining/compiler macros/etc
  inline cl stuff

real test framework, regression tests

arg count checking?

skip :coerce_foo when value is known to be correct type

store&use type info, allow type declarations
  (maybe some simple type propagation too?)

enforce same type on all exits from a block, or branches in an if
  (lazy way = specify coerce_a when no type specified externally,
   soem minimal type checking would be nicer though)

verifier in asm
  (possibly add fixer for some simple type errors too?)
---

http://www.lispworks.com/documentation/HyperSpec/Issues/iss152_w.htm
http://www.lispworks.com/documentation/HyperSpec/Body/03_af.htm
http://www.lispworks.com/documentation/HyperSpec/Body/05_b.htm
